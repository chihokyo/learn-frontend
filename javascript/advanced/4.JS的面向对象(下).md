# 面向对象（下）

由于 JS 的历史遗留问题。不是严格意义上的把 OOP 做的很好的语言，起码我觉得 ES5 和 ES6 之间有时候就难舍难分的。

这个学不好，其实写很多框架+打代码的时候都很困难。所以整理一下搞懂 JS 流程。

> JS 里函数才是一等公民，对象根本不算啥。如果你非说 JS 有对象，那我觉得 JS 里的所谓对象，也就是个内存地址而已。
>
> 换言之，只要是有内存地址的都可以算得上是对象吧。

## 1. 学习流程

此处缺个图，全部写完我在补。

- 创建对象的 n 种方式
- this 的指向问题
- Object 类的用法
- call/bind/apply 的使用方法+原理实现
- 构造函数+原型+原型链
- ES6 语法

## 2. 学习目标

- 可以手写模拟 new 创建的过程
- 可以把 this 的指向的一些题目写出来
- 可以手写 call/bind/apply 函数
- 可以手写 JS 的继承

## 3. 隐式原型 [[Prototype]]

首先要知道**什么是隐式原型？为什么叫隐式原型？什么数据类型有隐式原型？如何才能查看？**

为了要节省空间，这里先说一下原型的概念。

- 每个对象都是有一个原型的`[[Prototype]]` （早期 ECMA 没有规范去查看原型，这个双括号也只是个 es 空泛规定的，在不同的地方有自己不同的实现方式的时候他就这样写
- 后来浏览器为了让大家查看，各家自己规定了一些查看原型的方法，比如 \_\_proto\_\_，默认是一个空对象。
- 但是这并不是正规的，ES5 之后提供的 `Object.getPrototypeOf(obj)`

上面的一段话总结一下就是，每个对象都有一个对象原型（又叫**隐式原型**）。浏览器有浏览器的查看，es 有 es 的查看方法。

![image-20230120143521770](https://raw.githubusercontent.com/chihokyo/image_host/develop/image-20230120143521770.png)

> 原型有什么用呢？

```javascript
// 当我们从一个对象中获取某一个属性时, 它会触发 [[get]] 操作 obj["name"],obj.a 这些都是getter过程
// 1. 会优先在当前对象中去查找对应的属性, 如果找到就直接使用
// 2. 如果没有找到, 那么会沿着它的原型链去查找 [[Prototype]]
// obj.age = 18
obj.__proto__.age = 18;

console.log(obj.age);
```

![image-20220512145737319](https://raw.githubusercontent.com/chihokyo/image_host/develop/image-20220512145737319.png)

其实这个隐式原型，就是浏览器为了实现`[[Prototype]]` 搞出来的 \_\_proto\_\_

```javascript
var obj = {
  id: 'chin',
  // 本质就是每一个对象浏览器都给她弄了一个
  __proto__: {},
};
```

> 总结
>
> - 隐式原型是什么？→ 任何**对象**中都有的一个隐藏属性
> - 怎么才能获取？→ 浏览器里实现了`__proto__`(非标准 大家都用)。但正规的做法是`Object.getPrototypeOf(a);`
> - 隐式原型有什么意义？→ 当使用**[[getter]]**获取数据的时候，会优先在自己的**内部查找**。没有的话，会顺着**原型对象找**。

当定义一个函数的时候，内存图的表现？

```js
function Person() {}
```

![image-20230120152043503](https://raw.githubusercontent.com/chihokyo/image_host/develop/image-20230120152043503.png)

那么函数有没有隐式原型？有的！

所有的函数的父类，都是 Function，所以

```js
function Person() {}

console.log(Person.__proto__ === Function.prototype); // true
```

> 回头解答一下上面的问题
>
> - 隐式原型是什么？**隐式原型本质就是一个对象，一个地址。**
> - 为什么叫隐式的？因为这个一般无法获取，像是一个隐形的手。
> - 什么数据有？所有的对象和函数都有！对象的隐式原型指向他的亲生父亲。所有函数的亲生父亲是`Function.prototype`

## 4. 显式原型 prototype

上面说完了隐式的，现在开始显式的。

函数也是一个对象，所以上面**对象有的**，**函数这里也有**！！也叫显式原型！

这里可能理解起来有点麻烦。总结一下吧。这段很重要！

```js
const obj = {}; // 只是普通对象 → 都有__proto__
function foo() {} // 既是一个构造函数（说明可以new），又是一个普通函数（可以直接调用），又是一个函数对象（有自己的隐式原型__proto__ 是从new Function出来的）。三合一！因为函数就是JS的一等公民。
```

但是函数自己有一个自己**独有**的 **显式原型 prototype**！打印出来也是一个空对象！对象是没有**prototype 的**！

为什么叫显式原型？区别于上面的隐式，这个是所有函数都有的。可以直接你 ide 提示的。

> 这个显式原型啥作用？
>
> 为了构建对象的时候，把这个 prototype 赋值给 \_\_proto\_\_。也就是 new 的时候的其中一个步骤 ↑。

这个只在你的函数成为蜘蛛侠（new）的时候有作用，当你通过 new 让自己成为构造函数的时候，这个时候新建的对象的 \_\_proto\_\_ 就 **指向**了 函数的 prototype。

也就是 `对象.__proto__ = 函数.prototype` （内部自动操作）

其实函数.prototype 也就是一个对象地址 `函数.prototype={}，然后这个{}有个constructor属性的感觉`

```javascript
function foo() {
  console.log('foo');
}
var f1 = new foo();
console.log(f1.__proto__ === foo.prototype);
```

上面一段的内存图感觉

![image-20220411171027390](https://raw.githubusercontent.com/chihokyo/image_host/develop/image-20220411171027390.png)

## 5. 原型与原型链

### 什么是原型？

我感觉原型的**本质就是一个特殊的对象（地址）**，分为两大类。**显式原型和隐式原型**。这两个相互联系，但又各司其职。

- 相互联系 → 对象的隐式原型，指向了函数的显式原型。
- 各司其职 → `__proto__`是原型链的一条搜索查找绳子。`prototype`就像是印章的模子。两者都是对象。
  - 只要是对象就有`__proto__`
  - 只要是函数既有`__proto__`，又有`prototype`

### 什么是原型链？

原型链就是一种寻找变量的方式吧。自己找不到，就找原型链上的。顺着这个链子向上找~~ 一直找到顶层对象。

原型链在哪里？

> 所有对象都有原型链，包括原型对象`XXX.prototype`

![image-20230121220816952](https://raw.githubusercontent.com/chihokyo/image_host/develop/image-20230121220816952.png)

顶层原型是什么？

```js
const obj = {
  id: 'uu1',
};

obj.__proto === Object.prototype; // true
obj.__proto__.__proto__; // null
```

Object 上的就是顶层原型了。

## 5. JS 里的继承

如果 JS 能像 Java 一样，一个 extends 能解决多好。可惜了，即使 ES6 也有 extends，只是个语法糖本质还是用的原型链。所以还是要学会这个。

为什么要有继承？其实就是为了共通一些东西（主要是函数），这样可以省内存，并且写起来逻辑也更清晰。

```js
// 父类
function Person(name, age) {
  this.name = name;
  this.age = age;
}
Person.prototype.eat = function () {
  console.log('eating..');
};

// 子类
function Student(sitd) {
  this.sid = sid;
}
Student.prototype.study = function () {
  console.log('studying..');
};
```

> 这个到底怎么实现继承的呢？

### 原型链基本实现

下面的这段代码就可以实现继承，那么原理是什么呢？可以看一下内存图。

```js
// 父类
function Person(name, age) {
  this.name = name;
  this.age = age;
}
Person.prototype.eat = function () {
  console.log(`${this.name} is eating`);
};

// 子类
function Student(sitd) {
  this.sid = sid;
}
Student.prototype.study = function () {
  console.log(`${this.sid} is studying`);
};

// 这样就可以实现继承
Student.prototype = new Person();
// 为什么？
```

内存图解析

![image-20230122215408187](https://raw.githubusercontent.com/chihokyo/image_host/develop/image-20230122215408187.png)

上面虽然实现了共享这个 eating 的方法，但是会出现弊端。

- 弊端 1 打印不出具体属性 → 你打印 stu 这个对象，会出现 Person 这个构造函数。
- 弊端 2 修改了 a 对象的地址属性，b 也会会被修改 → 你在 Person 里添加一个数组这种带地址的数据，那么 stu 这个对象也被修改了
- 弊端 3 无法传递参数

```js
// 父类
function Person(name, age) {
  this.name = 'chin';
  this.age = 88;
  this.friends = [];
}
Person.prototype.eat = function () {
  console.log(`${this.name} is eating`);
};

// 子类
function Student(sitd) {
  this.sid = '001';
}
Student.prototype.study = function () {
  console.log(`${this.sid} is studying`);
};

// 弊端1
const stu = new Student();
console.log(stu); // Person { sid: '001' }

// 弊端2
const stu1 = new Student();
const stu2 = new Student();
stu1.friends.push('kitty');
console.log(stu2.friends); // [ 'kitty' ]

// 弊端3 无法传递参数
const stu3 = new Student(我想传递name，age，sid。这里怎么写啊，除非你改变原来student的方法);
```

### 借用构造函数

为了解决上面的弊端，下面有了一个新的写法 `constructor stealing`

```js
// 父类
function Person(name, age) {
  this.name = name;
  this.age = age;
}
Person.prototype.eat = function () {
  console.log(`${this.name} is eating`);
};

// 子类
function Student(name, age, sid) {
  Person.call(this, name, age);
  this.sid = sid;
}
Student.prototype.study = function () {
  console.log(`${this.sid} is studying`);
};

Student.prototype = new Person();

const stu = new Student('chin', 77, '001');
console.log(stu); // Person { name: 'chin', age: 77, sid: '001' }
```

上面的代码最重要的地方就是

```js
// 子类
function Student(name, age, sid) {
  // 前面上的时候说过了Person本身就是一个函数，使用call就是借用了这个Person函数
  // 也就是调用了一次Person()函数，但实际上使用的是Student的this
  Person.call(this, name, age);
  this.sid = sid;
}
```

内存图如下

![image-20230122221334044](https://raw.githubusercontent.com/chihokyo/image_host/develop/image-20230122221334044.png)

但是这种也有弊端

- 弊端 1 Person 被调用了 2 次，明明我只要 student 对象，为什么 Person 调用了两次？`new Person()`调用了一次，`Person.call()`
- 弊端 2 多了一些无用的 undefined

### 原型式继承

这是一个插曲。说一下某个 API 的原理。

就是我想通过一个对象，在这个对象基础上继承。怎么实现

```js
const obj = {
  name: 'chin',
  age: 99,
};

function createObject(object) {
  function Fn() {}
  // 本来Fn的prototype应该等于constructor{}
  // 这里直接等于了你传入的object对象
  // 这样的话 以后你用Fn原型生成的对象的__proto__都指向了object
  Fn.prototype = object;
  return new Fn();
}

const demo = createObject(obj);
console.log(demo.name); // chin
console.log(demo.age); // 99
```

> 但是随着大家的卷，出现了一个新的 API，`Object.create()` 可以实现上面的效果。所以就没人用了，也就是说`Object.create()`可以通过一个现有的对象生成一个新的对象。

### 寄生式继承

`工厂模式 + 原型式继承 = 寄生式继承`

为什么会有，解决了什么？按照上面学习的 Object。这个方法有一个弊端

```js
const obj = {
  name: 'chin',
  age: 88,
};

const student = Object.create(obj);

// 如果这个时候想给student添加一个weight属性怎么办
student.weight; // 这样就可以了呗
// 😱那如果有100个student对象呢？
```

所以就造出来了一个工厂函数，可以批量添加属性。

```js
const obj = {
  name: 'chin',
  age: 88,
};

function createStudent(weight) {
  const student = Object.create(obj);
  student.weight = weight;
  student.eat = function () {
    console.log('eating');
  };
  return student;
}

const newStu = createStudent(188);
console.log(newStu.weight); // 188
```

### 寄生组合式继承（最终方案）

终于走到最后了。。。

```js

```
